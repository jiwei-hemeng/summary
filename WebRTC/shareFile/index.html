<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>æ¥æ”¶æ–‡ä»¶</title>
  </head>
  <body>
    <!-- file2.html -->
    <div><button id="copy-link">å¤åˆ¶é“¾æ¥</button></div>
    <h2>æ¥æ”¶æ–‡ä»¶</h2>
    <div id="status">ç­‰å¾…è¿æ¥...</div>
    <a id="downloadLink" style="display: none">ä¸‹è½½</a>

    <script>
      let pc;
      const copyToClipboard = async (text) => {
        if (navigator.clipboard && navigator.clipboard.writeText) {
          await navigator.clipboard.writeText(text);
          alert("å¤åˆ¶æˆåŠŸ");
        } else {
          const textarea = document.createElement("textarea");
          textarea.value = text;

          // è®¾ç½®æ ·å¼ä½¿å…¶ä¸å¯è§
          textarea.style.position = "fixed";
          textarea.style.opacity = "0";
          textarea.style.left = "-9999px";
          textarea.style.top = "-9999px";

          // æ·»åŠ åˆ°æ–‡æ¡£ä¸­
          document.body.appendChild(textarea);

          // é€‰ä¸­æ–‡æœ¬
          textarea.select();
          textarea.setSelectionRange(0, textarea.value.length);

          // æ‰§è¡Œå¤åˆ¶å‘½ä»¤
          const success = document.execCommand("copy");

          // æ¸…ç†ä¸´æ—¶å…ƒç´ 
          document.body.removeChild(textarea);
          alert("å¤åˆ¶æˆåŠŸ");
        }
      };
      const ws = new WebSocket(`ws://172.20.10.4:8080`);
      let receivedBuffers = [];
      let fileMetadata = null;
      let selfId = null;
      const status = document.querySelector("#status");
      const link = document.getElementById("downloadLink");
      ws.onmessage = async (e) => {
        const msg = JSON.parse(e.data);
        if (msg.type === "offer") {
          pc = new RTCPeerConnection();
          pc.ondatachannel = (e) => {
            const dc = e.channel;
            dc.onmessage = (event) => {
              if (typeof event.data === "string") {
                const meta = JSON.parse(event.data);
                if (meta.type === "file-metadata") {
                  fileMetadata = meta;
                  status.textContent = `æ­£åœ¨æ¥æ”¶: ${meta.name}`;
                  link.style.display = "block";
                }
              } else {
                receivedBuffers.push(event.data);
                status.textContent = `æ¥æ”¶ä¸­... ${(
                  (receivedBuffers.reduce((a, b) => a + b.byteLength, 0) /
                    (fileMetadata?.size || 1)) *
                  100
                ).toFixed(1)}%`;
              }
            };
          };

          pc.onicecandidate = (e) => {
            if (e.candidate) {
              ws.send(
                JSON.stringify({
                  target: msg.from, // ğŸ‘ˆ ç›´æ¥ä½¿ç”¨ msg.fromï¼ˆserver.js å·²æ³¨å…¥ï¼‰
                  type: "candidate",
                  candidate: e.candidate,
                }),
              );
            }
          };
          // æ·»åŠ è¿æ¥çŠ¶æ€ç›‘æ§
          pc.onconnectionstatechange = () => {
            console.log("Connection state:", pc.connectionState);
            if (pc.connectionState === "failed") {
              console.error("WebRTC è¿æ¥å¤±è´¥ï¼å¯èƒ½æ˜¯ ICE æˆ– SDP é—®é¢˜");
            }
          };

          // æ·»åŠ  ICE æ”¶é›†çŠ¶æ€
          pc.onicegatheringstatechange = () => {
            console.log("ICE gathering state:", pc.iceGatheringState);
          };
          try {
            await pc.setRemoteDescription(msg.sdp);
            console.log("setRemoteDescription æˆåŠŸ");
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            ws.send(
              JSON.stringify({
                target: msg.from,
                type: "answer",
                sdp: {
                  type: answer.type, // æ˜¾å¼ç±»å‹
                  sdp: answer.sdp, // æ˜¾å¼ SDP å­—ç¬¦ä¸²
                },
              }),
            );
          } catch (err) {
            console.error("setRemoteDescription å¤±è´¥:", err); // ğŸ‘ˆ çœ‹è¿™é‡Œï¼
          }
        } else if (msg.type === "candidate") {
          await pc.addIceCandidate(msg.candidate);
        } else if (msg.type === "id") {
          selfId = msg.id;
        }
      };
      link.addEventListener("click", () => {
        const blob = new Blob(receivedBuffers, {
          type: "application/octet-stream",
        });
        const url = URL.createObjectURL(blob);
        link.href = url;
        link.download = fileMetadata.name;
        link.style.display = "";
        link.textContent = `ä¸‹è½½ ${fileMetadata.name}`;
        status.textContent = "âœ… æ¥æ”¶å®Œæˆï¼";
      });
      document.querySelector("#copy-link").addEventListener("click", () => {
        copyToClipboard(
          location.origin + "/WebRTC/shareFile/send.html?id=" + selfId,
        );
      });
    </script>
  </body>
</html>
