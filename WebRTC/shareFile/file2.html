<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>æ¥æ”¶æ–‡ä»¶</title>
  </head>
  <body>
    <!-- file2.html -->
    <div id="useId"></div>
    <h2>æ¥æ”¶æ–‡ä»¶</h2>
    <div id="status">ç­‰å¾…è¿æ¥...</div>
    <a id="downloadLink" style="display: none">ä¸‹è½½</a>

    <script>
      let pc;
      const ws = new WebSocket("ws://localhost:8080");
      let receivedBuffers = [];
      let fileMetadata = null;
      const status = document.querySelector("#status");
      const link = document.getElementById("downloadLink");
      ws.onmessage = async (e) => {
        const msg = JSON.parse(e.data);
        if (msg.type === "offer") {
          pc = new RTCPeerConnection();
          pc.ondatachannel = (e) => {
            const dc = e.channel;
            dc.onmessage = (event) => {
              if (typeof event.data === "string") {
                const meta = JSON.parse(event.data);
                if (meta.type === "file-metadata") {
                  fileMetadata = meta;
                  status.textContent = `æ­£åœ¨æ¥æ”¶: ${meta.name}`;
                  link.style.display = "block";
                }
              } else {
                receivedBuffers.push(event.data);
                status.textContent = `æ¥æ”¶ä¸­... ${(
                  (receivedBuffers.reduce((a, b) => a + b.byteLength, 0) /
                    (fileMetadata?.size || 1)) *
                  100
                ).toFixed(1)}%`;
              }
            };
          };

          pc.onicecandidate = (e) => {
            if (e.candidate) {
              ws.send(
                JSON.stringify({
                  target: msg.from, // ğŸ‘ˆ ç›´æ¥ä½¿ç”¨ msg.fromï¼ˆserver.js å·²æ³¨å…¥ï¼‰
                  type: "candidate",
                  candidate: e.candidate,
                })
              );
            }
          };
          // æ·»åŠ è¿æ¥çŠ¶æ€ç›‘æ§
          pc.onconnectionstatechange = () => {
            console.log("Connection state:", pc.connectionState);
            if (pc.connectionState === "failed") {
              console.error("WebRTC è¿æ¥å¤±è´¥ï¼å¯èƒ½æ˜¯ ICE æˆ– SDP é—®é¢˜");
            }
          };

          // æ·»åŠ  ICE æ”¶é›†çŠ¶æ€
          pc.onicegatheringstatechange = () => {
            console.log("ICE gathering state:", pc.iceGatheringState);
          };
          try {
            await pc.setRemoteDescription(msg.sdp);
            console.log("setRemoteDescription æˆåŠŸ");
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            ws.send(
              JSON.stringify({
                target: msg.from,
                type: "answer",
                sdp: {
                  type: answer.type, // æ˜¾å¼ç±»å‹
                  sdp: answer.sdp, // æ˜¾å¼ SDP å­—ç¬¦ä¸²
                },
              })
            );
          } catch (err) {
            console.error("setRemoteDescription å¤±è´¥:", err); // ğŸ‘ˆ çœ‹è¿™é‡Œï¼
          }
        } else if (msg.type === "candidate") {
          await pc.addIceCandidate(msg.candidate);
        } else if (msg.type === "id") {
          document.querySelector("#useId").textContent = `ç”¨æˆ·id: ${msg.id}`;
        }
      };
      link.addEventListener("click", () => {
        const blob = new Blob(receivedBuffers, {
          type: "application/octet-stream",
        });
        const url = URL.createObjectURL(blob);
        link.href = url;
        link.download = fileMetadata.name;
        link.style.display = "";
        link.textContent = `ä¸‹è½½ ${fileMetadata.name}`;
        status.textContent = "âœ… æ¥æ”¶å®Œæˆï¼";
      });
    </script>
  </body>
</html>
