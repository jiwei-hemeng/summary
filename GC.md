## 什么是垃圾回收

 垃圾回收机制也称`Garbage Collection`简称GC。在JavaScript中拥有自动的垃圾回收机制，通过一些回收算法，找出不再使用引用的变量或属性，由JS引擎按照固定时间间隔周期性的释放其所占的内存空间 

 JavaScript是一门单线程的语言，每次执行垃圾回收，会使程序应用逻辑暂停，执行完垃圾后回收在执行应用逻辑，这种行为称为全停顿，所以一般垃圾回收会在cpu闲时进行。 

 常见的算法策略 

+ 引用计数算法
+ 标记清除算法
+ 标记整理
+ 分代回收

##  引用计数标记

 **策略思想：** 

+ 跟踪记录每个变量值被使用的次数
+ 当声明一个变量并且将一个引用类型数据赋值给这个变量的时候，这个引用类型数据的引用次数就标记为 1
+ 如果当这个引用类型数据又赋值给另一个变量，那么引用次数就+1
+ 如果变量被其他的值覆盖，则引用次数-1
+ 当这个引用类型数据的引用次数变为0的时候,这个变量就没有被使用了，也无法访问，垃圾回收器就会在执行时，销毁引用次数为0的引用类型数据，回收其所占用的内存空间。

**优点**

+ 引用计数为零时，发现垃圾立即回收
+ 最大限度减少程序暂停

**缺点**

- 无法回收循环引用的对象

##  标记清除算法

> #### 核心思想:  分标记和清除两个阶段完成。 

 **大概过程：** 

- 垃圾收集器在运行时会给内存中所有的变量都加上一个标记，假设内存中所有的对象全部是垃圾，全部标记为0
- 然后从各个根对象开始遍历，把不是垃圾的节点改成1
- 清理所有标记为0的垃圾，销毁并回收它们所占用的内存空间
- 最后把所有内存中对象标记修改为0，等待下一轮的垃圾回收

**优点：**

- 实现简单，标记情况无非是打与不打的两种情况，通过二进制（0和1）就可以为其标记。
- 能够回收循环引用的对象
- 是v8引擎使用最多的算法。

**缺点：**

在清除垃圾之后，剩余对象的内存位置是不变的，就会导致空闲内存空间不连续。这样就出现了内存碎片，并且由于剩余空间不是整块，就需要内存分配的问题。

##  标记整理算法

 标记整理（Mark-Compact）算法，就是可以有效的解决，它是在标记结束后标记整理算法会将不需要清理的对象向内存一端移动，最后清理边界的内存。

 ## Scavenge算法  

 该算法将新生代分为两部分，一部分叫做from（对象区域），另一部分叫做to（空闲区域），新加入的对象首先存放在from区域；

![Scavenge算法](https://jiwei-hemeng.github.io/summary/assets/images/1155527-20220320222512252-618938289.png) 

 from区域写满的时候，对from区域开始进行垃圾回收。首先对from区域的垃圾进行标记(红色代表标记为垃圾)； 

![Scavenge算法](https://jiwei-hemeng.github.io/summary/assets/images/1155527-20220320222532461-104056076.png)

 将存活的对象复制到to区域中，并且有序地排列起来，复制后的to区域就没有内存碎片了； 

![Scavenge算法](https://jiwei-hemeng.github.io/summary/assets/images/1155527-20220320222624767-871994632.png)

 清空from区域； 

![ 清空from区域](https://jiwei-hemeng.github.io/summary/assets/images/1155527-20220320222646324-832514264.png)

 from区域和to区域进行反转，也就是原来的from区域变为to区域，原来的to区域变成from区域。 

![ from区域和to区域进行反转，也就是原来的from区域变为to区域，原来的to区域变成from区域](https://jiwei-hemeng.github.io/summary/assets/images/1155527-20220320222902040-547647537.png)

 Scavenge算法在时间效率上有着优异的表现，缺点是只能使用堆内存中的一半，如果存储容量过大，就会导致每次清理的时间过长，效率低，因此经过两次垃圾回收之后依然存活的对象会晋升为老生代对象，另外还有一种情况，如果复制一个对象到空闲区时，空闲区空间占用超过了 25%，那么这个对象会被直接晋升到老生代空间中，设置为 25% 的比例的原因是，当完成 `Scavenge` 回收后，空闲区将翻转成对象区域，继续进行对象内存的分配，若占比过大，将会影响后续内存分配。 

## V8引擎的垃圾回收

- V8引擎的垃圾回收采用标记清除法与分代回收法
- 分为新生代和老生代

**针对不同对象采用不同算法：**

（1）新生代：对象的存活时间较短。新生对象或只经过一次垃圾回收的对象。

（2）老生代：对象存活时间较长。经历过一次或多次垃圾回收的对象。

### 回收新生代对象

回收新生代对象主要采用复制算法（Scavenge 算法）加标记整理算法。而Scavenge 算法的具体实现，主要采用了Cheney算法。

### 老生代-标记整理法

- 标记：和标记 - 清除的标记过程一样，从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素标记为活动对象；
- 整理：让所有存活的对象都向内存的一端移动

##  哪些情况容易引起内存泄漏 

+ 意外的全局变量

  全局变量等同于在window上添加属性，因此在函数执行完毕，依旧能够访问到它，因此不能够被回收。

+ 闭包使用不当

+ 被遗忘的定时器或事件回调函数

   当dom元素被移除时，因为是周期定时器的缘故，定时器回调函数始终没法被回收，这也致使了定时器会一直对数据serverData保持引用，好的作法是在不须要时中止定时器 

  ```js
  var serverData = loadData();
  setInterval(function () {
      var dom = document.getElementById('renderer');
      if (dom) {
          dom.innerHTML = JSON.stringify(serverData);
      }
  }, 3000);
  ```

   另外在使用事件监听时，若是再也不须要监听记得移除监听事件 

  ```js
  var element = document.getElementById('button');
  function onclick(event) {
    element.innerHTML = 'text';
  };
  element.addEventListener('click', onclick);
  element.removeEventListener('click', onclick);
  ```

  
